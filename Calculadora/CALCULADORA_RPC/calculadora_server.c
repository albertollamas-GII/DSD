/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include "math.h"
#include <stdlib.h>
#include <limits.h>

double *
suma_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double result;

	result = arg1 + arg2;

	return &result;
}

double *
resta_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1 - arg2;

	return &result;
}

double *
multiplicacion_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1 * arg2;

	return &result;
}

double *
division_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;

	if (arg2 != 0.0)
	{
		result = arg1 / arg2;
	}
	else
	{
		printf("\nNo se puede dividir entre 0, Introduce otro nÃºmero");
		result = 0.0;
	}

	return &result;
}

ecuacionCuadrada *
cuadratica_1_svc(double arg1, double arg2, double arg3,  struct svc_req *rqstp)
{
	static ecuacionCuadrada  result;
	result.a = arg1; result.b = arg2; result.c = arg3;

	if (result.a != 0){
		double discriminante = pow(result.b, 2.0) - 4 * result.a * result.c;
		if (discriminante > 0) {
			result.res1 = (-result.b + sqrt(discriminante)) / (2 * result.a);
			result.res2 = (-result.b - sqrt(discriminante)) / (2 * result.a);
		} else if (discriminante == 0){
			result.res1 = result.res2 = (-result.b) / (2*result.a);	
		} else {
			printf("\nNo tiene raices reales");
			result.res1 = result.res2 = INT_MIN;
		}
	} else {
		printf("\nInfinito");
		result.res1 = result.res2 = INT_MIN;
	}
	

	return &result;
}

vect *
sumavectores_1_svc(vect arg1, vect arg2,  struct svc_req *rqstp)
{
	static vect  result;

	result.vect_len = arg1.vect_len;
	result.vect_val = malloc(result.vect_len * sizeof(double));

	for (int i = 0; i < result.vect_len; i++)
		result.vect_val[i] = arg1.vect_val[i] + arg2.vect_val[i];

	return &result;
}

vect *
restavectores_1_svc(vect arg1, vect arg2,  struct svc_req *rqstp)
{
	static vect  result;

	result.vect_len = arg1.vect_len;
	result.vect_val = malloc(result.vect_len * sizeof(double));

	for (int i = 0; i < result.vect_len; i++)
		result.vect_val[i] = arg1.vect_val[i] - arg2.vect_val[i];

	return &result;
}

vect *
productovectores_1_svc(vect arg1, vect arg2,  struct svc_req *rqstp)
{
	static vect  result;

	result.vect_len = arg1.vect_len;
	result.vect_val = malloc(result.vect_len * sizeof(double));

	for (int i = 0; i < result.vect_len; i++)
		result.vect_val[i] = arg1.vect_val[i] * arg2.vect_val[i];

	return &result;
}

vect *
divisionvectores_1_svc(vect arg1, vect arg2,  struct svc_req *rqstp)
{
	static vect  result;

	result.vect_len = arg1.vect_len;
	result.vect_val = malloc(result.vect_len * sizeof(double));

	for (int i = 0; i < result.vect_len; i++)
		result.vect_val[i] = arg1.vect_val[i] / arg2.vect_val[i];

	return &result;
}

double *
productoescalar_1_svc(vect arg1, vect arg2,  struct svc_req *rqstp)
{
	static double  result;

	for (int i = 0; i < arg1.vect_len; i++)
		result += arg1.vect_val[i] * arg2.vect_val[i];

	return &result;
}
